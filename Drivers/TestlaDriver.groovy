/*
* TeslaDriver
*
* Description:
* This Hubitat driver is designed for use with a virtual device to connect to Tesla devices.
* Right now the driver is geared towards obtaining data from a Tesla PowerWall.
*
* Preferences:
* DeviceIP = REQUIRED. This identifies the IP of the device to connect to
* RefreshRate = REQUIRED - DEFAULT = 5 minutes. The rate at which the device will be polled (in minutes)
* Enable Child Devices = OPTIONAL - DEFAULT = false. Whether child devices will be generated by the driver, requires TeslaChild.groovy also be loaded
* LogType = OPTIONAL - DEFAULT = Info. Only basic information will be stored to the log
* ShowAllPreferences = OPTIONAL - DEFAULT = true. Whether the other preferences are to be displayed or not
*
* Features List:
* Processes data from local connection method (at this time: aggregate, grid status, sitemaster, registration, powerwalls, & system status)
* Ability to check drdsnell.com for updates to the driver
* 
* Licensing:
* Copyright 2021 David Snell
* Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
* in compliance with the License. You may obtain a copy of the License at: http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
* on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
* for the specific language governing permissions and limitations under the License.
*
* Version Control:
* 1.0.1 - Replaced all instances of boolean attributes with strings because boolean attributes are not valid
*   + changes to logging and update methods
* 1.0.0 - "Release" version
* 0.3.3 - Bug fix and nomenclature for RefreshRate
* 0.3.2 - Aggregate data should be fixed
* 0.3.1 - Additional logging for Aggregates due to odd behavior
* 0.3.0 - Rework of aggregate and general status messaging
* 0.2.5 - Work on the Device data parsing
* 0.2.4 - Fixed a check on a possibly null variable and removed attempts for data that were not good anymore
* 0.2.3 - Cleaned up a bunch of variable names, pulled in more data, and other fixes
* 0.2.2 - Changed way serial numbers are handled due to Tesla's odd use of them
* 0.2.1 - Handling powerwall data now, json was "broken" by quotes Tesla included in the message
* 0.2.0 - Changed name and started parsing additional API calls
* 0.1.7 - Added more variables and attempts to pull in more API calls just for raw data at this point
* 0.1.6 - Reworked parsing of returned data so it can be processed, since it was not actually json formatted
* 0.1.5 - Response coming back for local was not json... specifically requesting content type now
* 0.1.4 - Enabled some more trace logging for development purposes
* 0.1.3 - Enhanced error checking & ignores SSL errors from Tesla's self-signed certificates
* 0.1.2 - Correction to Preferences and handling of data method
* 0.1.1 - Changes to attempt local support
* 0.1.0 - Initial version
* 
* Thank you(s):
* @Cobra for inspiration of how I perform driver version checking.
* @jared.zimmerman & @scottgu3 for all their samples and testing of the driver
*/
import groovy.json.*;

metadata{
	definition ( name: "TeslaDriver", namespace: "Snell", author: "David Snell", importUrl: "https://www.drdsnell.com/projects/hubitat/drivers/TeslaDriver.groovy" ) {
		// Attempting to indicate what capabilities the device should be capable of
		capability "Sensor"
		capability "Refresh"
        capability "Battery"
		
		// Commands in the driver
        command "updateCookie"
		
		// Attributes in the driver
		// Driver identifies the driver being used for update purposes
		attribute "Driver", "string"
        // Version number, meant more for when I add in self-updating and related notifications
		attribute "Version", "string"
        // Grid Status indicates the grid connection state in slightly more human-understandable terms
		attribute "Grid Status", "string"
        attribute "Grid Connection Possible", "string"
        attribute "Device Type", "string"
        attribute "Tesla Device Version", "string"
        attribute "System Energy (kWh)", "number"
        attribute "System Power (kW)", "number"
        attribute "System Status", "string"
        attribute "System Running", "string"
        attribute "Connected To Tesla", "string"
        attribute "Receiving Power From Grid", "string"
        attribute "Privacy Notice Signed", "string"
        attribute "Under Warranty", "string"
        attribute "Receive Marketing", "string"
        attribute "System Registered", "string"
        attribute "Registration Period Over", "string"
        attribute "Instant Power", "number"
        attribute "Instant Reactive Power", "number"
        attribute "Instant Apparent Power", "number"
        attribute "Instant Total Current", "number"
        attribute "Energy Exported", "number"
        attribute "Energy Imported", "number"
        attribute "Frequency (Hz)", "number"

        attribute "Site Instant Power", "number"
        attribute "Site Instant Reactive Power", "number"
        attribute "Site Instant Apparent Power", "number"
        attribute "Site Instant Total Current", "number"
        attribute "Site Energy Exported", "number"
        attribute "Site Energy Imported", "number"
        attribute "Site Energy Exported Daily", "number"
        attribute "Site Energy Imported Daily", "number"
        attribute "Site Frequency (Hz)", "number"
        attribute "Site Voltage", "number"

        attribute "Solar Instant Power", "number"
        attribute "Solar Instant Reactive Power", "number"
        attribute "Solar Instant Apparent Power", "number"
        attribute "Solar Instant Total Current", "number"
        attribute "Solar Energy Exported", "number"
        attribute "Solar Energy Imported", "number"
        attribute "Solar Energy Exported Daily", "number"
        attribute "Solar Energy Imported Daily", "number"
        attribute "Solar Frequency (Hz)", "number"
        attribute "Solar Voltage", "number"

        attribute "Battery Instant Power", "number"
        attribute "Battery Instant Reactive Power", "number"
        attribute "Battery Instant Apparent Power", "number"
        attribute "Battery Instant Total Current", "number"
        attribute "Battery Energy Exported", "number"
        attribute "Battery Energy Imported", "number"
        attribute "Battery Energy Exported Daily", "number"
        attribute "Battery Energy Imported Daily", "number"
        attribute "Battery Frequency (Hz)", "number"
        attribute "Battery Voltage", "number"

        attribute "Load Instant Power", "number"
        attribute "Load Instant Reactive Power", "number"
        attribute "Load Instant Apparent Power", "number"
        attribute "Load Instant Total Current", "number"
        attribute "Load Energy Exported", "number"
        attribute "Load Energy Imported", "number"
        attribute "Load Energy Exported Daily", "number"
        attribute "Load Energy Imported Daily", "number"
        attribute "Load Frequency (Hz)", "number"
        attribute "Load Voltage", "number"
        attribute "Grid Being Used", "string"

        attribute "Powerwall(s) Charging", "string"
        attribute "Solar Generating Power", "string"
        
	}

    def cookieEnum = 
        ["0 2 2 * * ? *" : "Every Day",
         "0 2 2 ? * SUN *" : "Every Week",
         "0 2 2 1 * ? *" : "Once a Month",
         "0" : "Manual"];

	preferences{
		section{
            if( ShowAllPreferences || ShowAllPreferences == null ){ // Show the preferences options
                // String to retain the device's IP or hostname
			    input( type: "string", name: "DeviceIP", title: "<font color='FF0000'><b>Device's IP/Hostname</b></font>", required: false )
                // Enum to allow selecting the refresh rate that the device will be checked
                input( type: "string", name: "email", title: "<font color='FF0000'><b>Powerwall Email</b></font>", required: false )
                // Enum to allow selecting the refresh rate that the device will be checked
                input( type: "password", name: "password", title: "<font color='FF0000'><b>Powerwall Password</b></font>", required: false )
                // Enum to allow selecting the refresh rate that the device will be checked
                input( type: "enum", name: "RefreshRate", title: "<b>Refresh Rate</b>", required: false, multiple: false, options: [ "1 minute", "5 minutes", "10 minutes", "15 minutes", "30 minutes", "1 hour", "3 hours", "Manual" ], defaultValue: "5 minutes" )
                //Cookie Refresh
                input( type: "enum", name: "CookieRefresh", title: "<b>How often refresh Cookie?</b>", required: false, multiple: false, options: cookieEnum, defaultValue: "5 minutes" )
                // Bool about whether child devices will be enabled
    			input( type: "bool", name: "ChildrenEnabled", title: "<b>Enable Child Devices?</b>", description: "Once enabled, child devices will be made for added sensors.", required: false, defaultValue: false )
				// Enum to set the level of logging that will be used
    			input( type: "enum", name: "LogType", title: "<b>Enable Logging?</b>", required: true, multiple: false, options: [ "None", "Info", "Debug", "Trace" ], defaultValue: "Info" )
                // Bool to set whether the other preferences should be displayed or not
                input( type: "bool", name: "UpdateDaily", title: "<b>Update Daily Energy</b>", defaultValue: false )
                // Bool to set whether the other preferences should be displayed or not
 				input( type: "bool", name: "ShowAllPreferences", title: "<b>Show All Preferences?</b>", defaultValue: true )
                // Bool to schedule midnight 
            } else { // Preferences should be hidden so only show the preference to show them or not
                input( type: "bool", name: "ShowAllPreferences", title: "<b>Show All Preferences?</b>", defaultValue: true )
            }
		}
	}
}

// updated is called whenever device parameters are saved
// Sets the current version of the driver, basic settings, and schedules
def updated(){
	// Clear all the state information
	//state.clear()

	// Set some basic settings and clear the failures value
	state.Version = "1.0.1"
	state.Driver = "TeslaDriver"

    // Set basic info logging if for some reason the preference is null
    if( LogType == null ){
        LogType = "Info"
    }
    
    // Check if children are disabled and if any exist
    if( !ChildrenEnabled && getChildDevices() != null ){
        // Delete all children
        Logging( "Child devices disabled, but had been enabled, deleting child devices", 3 )
	    getChildDevices().each{
		    deleteChildDevice( it.deviceNetworkId )
	    }
    }
    
    // Check if the refresh rate is not set for some reason and putting it at the default
    if( RefreshRate == null ){
        RefreshRate = "5 minutes"
    }
	// Set the schedule for driver version check and refreshing for data
    unschedule()
	// Check what the refresh rate is set for then run it
	switch( RefreshRate ){
		case "1 minute":
			runEvery1Minute( refresh )
			break
		case "5 minutes":
			runEvery5Minutes( refresh )
			break
        case "10 minutes":
			runEvery10Minutes( refresh )
			break
		case "15 minutes":
			runEvery15Minutes( refresh )
			break
    	case "30 minutes":
    		runEvery30Minutes( refresh )
			break
        case "1 hour":
    		runEvery1Hour( refresh )
			break
        case "3 hours":
            runEvery3Hours( refresh )
            break
        case "Manual":
			break
	}
    if (CookieRefresh != "0"){
        schedule(CookieRefresh, "updateCookie");
    }

    Logging( "Refresh rate: ${ RefreshRate }", 3 )

    if (UpdateDaily){
        schedule("1 2 0 ? * * *", "getMidnightData");
        //getMidnightData();
    }
    
    schedule( new Date(), CheckForUpdate )
	Logging( "Updated", 2 )
}

def updateCookie(){

    if (email && password){
		def result = false
        cookie = null;
        
        def body = [
            username: "customer",
            email: "${email}",
            force_sm_off: "false",
            password: "${password}",
        ];        
        
        def bodyJSON = JsonOutput.toJson(body);	
        log.debug(bodyJSON);

        httpPost(
            [
                uri: "https://${DeviceIP}/api/login/Basic",
                headers: 
                [ 
                    "Origin": "https://${DeviceIP}",
                    "Referer": "https://${DeviceIP}",
                    "Connection": "keep-alive",
                    "CSRF-Token": "undefined",
                    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 11_3_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36",
                    
                    "Accept": "application/json, text/plain, */*",
                    "Accept-Encoding": "gzip, deflate, br",
                    "Accept-Language": "en-US,en;q=0.9",
                ],
                requestContentType: "application/x-www-form-urlencoded",
                body: body,
                ignoreSSLIssues: true
            ]
        )
        { resp ->
            headers = resp.getHeaders();
            data = resp.getData();
            cookie = "";
            headers.each{header->
                temp = header.toString() - " Path=/"
                if (temp.startsWith("Set-Cookie")){
                    if (cookie!="") cookie += " ";
                    cookie += (temp - "Set-Cookie: ");
                }
            };
            state.cookie = cookie;
        }
	}
	else return [];
}

def getMidnightData(){
    var1 = 'Site Energy Imported'
    var2 = var1+' at Midnight'
    state."${ var2 }" = state."${ var1 }";

    var1 = 'Site Energy Exported'
    var2 = var1+' at Midnight'
    state."${ var2 }" = state."${ var1 }";

    var1 = 'Solar Energy Imported'
    var2 = var1+' at Midnight'
    state."${ var2 }" = state."${ var1 }";

    var1 = 'Solar Energy Exported'
    var2 = var1+' at Midnight'
    state."${ var2 }" = state."${ var1 }";

    var1 = 'Load Energy Imported'
    var2 = var1+' at Midnight'
    state."${ var2 }" = state."${ var1 }";

    var1 = 'Load Energy Exported'
    var2 = var1+' at Midnight'
    state."${ var2 }" = state."${ var1 }";

    var1 = 'Battery Energy Imported'
    var2 = var1+' at Midnight'
    state."${ var2 }" = state."${ var1 }";

    var1 = 'Battery Energy Exported'
    var2 = var1+' at Midnight'
    state."${ var2 }" = state."${ var1 }";
}



// refresh runs the device polling
def refresh(){
    if( DeviceIP != null ){
        ConnectLocal()
    } else {
        sendEvent( name: "Status", value: "Local Method: Lacking device IP address/hostname" )
        Logging( "Cannot use local method without device IP/hostname", 5 )
    }
}

// Connect to the local device for information
def ConnectLocal(){

    // Try to connect locally for status information
    if (state.cookie == null || !state.cookie) updateCookie();

    def header = ['cookie': state.cookie];
        
    def Params = [ uri: "https://${ DeviceIP }/api/meters/aggregates", headers: header, contentType: "application/json", ignoreSSLIssues: true ] // Aggregated info
    asynchttpGet( "ParseAggregates", Params )

    Params = [ uri: "https://${ DeviceIP }/api/system_status/grid_status", headers: header, contentType: "application/json", ignoreSSLIssues: true ] // grid status
    asynchttpGet( "ParseGridStatus", Params )

    Params = [ uri: "https://${ DeviceIP }/api/customer/registration", headers: header, contentType: "application/json", ignoreSSLIssues: true ] // customer registration information
    asynchttpGet( "ParseRegistration", Params )

    Params = [ uri: "https://${ DeviceIP }/api/powerwalls", headers: header, contentType: "application/json", ignoreSSLIssues: true ] // powerwall information
    asynchttpGet( "ParsePowerwalls", Params )

    Params = [ uri: "https://${ DeviceIP }/api/sitemaster", headers: header, contentType: "application/json", ignoreSSLIssues: true ] // limited information about whether system is running
    asynchttpGet( "ParseSitemaster", Params )

    Params = [ uri: "https://${ DeviceIP }/api/system_status/soe", headers: header, contentType: "application/json", ignoreSSLIssues: true ] // System status
    asynchttpGet( "ParseSystemStatus", Params )

    Params = [ uri: "https://${ DeviceIP }/api/site_info", headers: header, contentType: "application/json", ignoreSSLIssues: true ] // Site info
    asynchttpGet( "ParseSiteInfo", Params )
}



// Parse the aggregate data received before passing it for processing
def ParseAggregates( resp, data ){
	switch( resp.status ){
		case 200:
			def TempData
            TempData = parseJson( resp.data )
            NumberDevices = TempData.size()
            if( NumberDevices == 4 ){
                ProcessData( TempData.site, "site" )
                ProcessData( TempData.solar, "solar" )
                ProcessData( TempData.battery, "battery" )
                ProcessData( TempData.load, "load" )
            }
            UpdateStatus()
            Logging( "Connected to Tesla for Aggregate.", 4 )
			sendEvent( name: "Status", value: "Local Connection Good" )
			break
        case 408:
            Logging( "Timeout connecting to Tesla for Aggregate.", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed - Timeout" )
			break
		default:
            Logging( "Error connecting to Tesla for Aggregate. ${ resp.status }", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed" )
			break
	}
}

// Parse the data received before passing it for processing
def ParseDevice( resp, data ){
	switch( resp.status ){
		case 200:
            Logging( "Device data = ${ resp.data }", 4 )
            Data = parseJson( resp.data )
            ProcessData( Data.connection, "${ Data.location }" )
            ProcessData( Data.Cached_readings, "${ Data.location }" )
			Logging( "Connected to Tesla for Device: ${ Data.location }.", 4 )
			break
        case 408:
            Logging( "Timeout connecting to Tesla for Specific Device.", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed - Timeout" )
			break
		default:
            Logging( "Error connecting to Tesla for Specific Device. ${ resp.status }", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed" )
			break
	}
}

// Parse the data received before passing it for processing
def ParseGridStatus( resp, data ){
	switch( resp.status ){
		case 200:
            Logging( "GridStatus data = ${ resp.data }", 4 )
			Data = parseJson( resp.data )
            ProcessData( Data, null )
            Logging( "Connected to Tesla for Grid Status.", 4 )
			break
        case 408:
            Logging( "Timeout connecting to Tesla for Grid Status.", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed - Timeout" )
			break
		default:
            Logging( "Error connecting to Tesla for Grid Status. ${ resp.status }", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed" )
			break
	}
}

// Parse the data received before passing it for processing
def ParseRegistration( resp, data ){
	switch( resp.status ){
		case 200:
            Logging( "Registration data = ${ resp.data }", 4 )
            Data = parseJson( resp.data )
            ProcessData( Data, null )
            Logging( "Connected to Tesla for Registration.", 4 )
			break
        case 408:
            Logging( "Timeout connecting to Tesla for Registration.", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed - Timeout" )
			break
		default:
            Logging( "Error connecting to Tesla for Registration. ${ resp.status }", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed" )
			break
	}
}

// Parse the data received before passing it for processing
def ParsePowerwalls( resp, data ){
	switch( resp.status ){
		case 200:
            Logging( "Powerwall(s) data = ${ resp.data }", 4 )
            def TempData = "${ resp.data }"
            // Deal with "offending" characters in data as they are discovered
            if( TempData.contains( "\"STOP SYSTEM\"" ) ){
                TempData = TempData.replaceAll( "\"STOP SYSTEM\"", "STOP SYSTEM" )
            }
            if( TempData.contains( "\"RUN WIZARD\"" ) ){
                TempData = TempData.replaceAll( "\"RUN WIZARD\"", "RUN WIZARD" )
            }
            Data = parseJson( TempData )
            Logging( "# Powerwall(s) = ${ Data.powerwalls.size() }", 4 )
            Data.powerwalls.each(){
                ProcessData( it, "Powerwall ${ it.PackageSerialNumber }" )
            }
            Logging( "Connected to Tesla for Powerwall(s).", 4 )
			break
        case 408:
            Logging( "Timeout connecting to Tesla for Powerwall(s).", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed - Timeout" )
			break
		default:
            Logging( "Error connecting to Tesla for Powerwall(s). ${ resp.status }", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed" )
			break
	}
}

// Parse the data received before passing it for processing
def ParseSitemaster( resp, data ){
	switch( resp.status ){
		case 200:
            Logging( "Sitemaster data = ${ resp.data }", 4 )
			Data = parseJson( resp.data )
            ProcessData( Data, null )
            Logging( "Connected to Tesla for Sitemaster.", 4 )
			break
        case 408:
            Logging( "Timeout connecting to Tesla for Sitemaster.", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed - Timeout" )
			break
		default:
            Logging( "Error connecting to Tesla for Sitemaster. ${ resp.status }", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed" )
			break
	}
}


// Parse the data received before passing it for processing
def ParseSystemStatus( resp, data ){
	switch( resp.status ){
		case 200:
            Logging( "SystemStatus data = ${ resp.data }", 4 )
			Data = parseJson( resp.data )
            ProcessData( Data, null )
            Logging( "Connected to Tesla for System Status.", 4 )
			break
        case 408:
            Logging( "Timeout connecting to Tesla for System Status.", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed - Timeout" )
			break
		default:
            Logging( "Error connecting to Tesla for System Status. ${ resp.status }", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed" )
			break
	}
}

// Parse the data received before passing it for processing
def ParseSiteInfo( resp, data ){
	switch( resp.status ){
		case 200:
            Logging( "Site Info data = ${ resp.data }", 4 )
            Data = parseJson( resp.data )
            ProcessData( Data, null )
			Logging( "Connected to Tesla for Site Info.", 4 )
			break
        case 408:
            Logging( "Timeout connecting to Tesla for Site Info.", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed - Timeout" )
			break
		default:
            Logging( "Error connecting to Tesla for Site Info. ${ resp.status }", 5 )
			sendEvent( name: "Status", value: "Local Connection Failed" )
			break
	}
}

// Updates the overall System Status once data has all been requested and processed for Aggregates
def UpdateStatus(){
    if( state.'Site Instant Power' > 0 ){
        ProcessEvent( "Grid Being Used", "true" )
    } else {
        ProcessEvent( "Grid Being Used", "false" )
    }
    if( state.'Battery Instant Power' > 0 ){
        ProcessEvent( "Powerwall(s) Charging", "false" )
    } else {
        ProcessEvent( "Powerwall(s) Charging", "true" )
    }
    if( state.'Solar Instant Power' > 0 ){
        ProcessEvent( "Solar Generating Power", "true" )
    } else {
        ProcessEvent( "Solar Generating Power", "false" )
    }
}

// Process received data
def ProcessData( Data, Device = null ){
    if( Device != null ){
        if( Device.contains( "Powerwall" ) ){
            Logging( "Processing Powerwall size = ${ Data.size() }", 4 )
        } else {
            Logging( "Processing ${ Device } size = ${ Data.size() }", 4 )
        }
    } else {
        Logging( "Processing other size = ${ Data.size() }", 4 )
    }
    //log.debug(Data);
    Data.each{
        switch( it.key ){
            // Aggregates
            case "last_communication_time":
            case "i_a_current":
            case "i_b_current":
            case "i_c_current":
            case "timeout":
            case "a":
            // Powerwall
            case "PackagePartNumber":
            case "grid_state":
            case "grid_reconnection_time_seconds":
            case "under_phase_detection":
            case "updating":
            case "Type":
            case "bc_type":
            // Site Info
            case "max_site_meter_power_kW":
            case "min_site_meter_power_kW":
            case "max_system_power_kW":
            case "max_system_energy_kWh":
            case "site_name":
            case "timezone":
            case "grid_code":
            case "grid_voltage_setting":
            case "grid_freq_setting":
            case "grid_phase_setting":
            case "country":
            case "state":
            case "distributor":
            case "utility":
            case "retailer":
            case "region":
            // Device specific data
            case "ip_address":
            case "port":
            case "short_id":
            case "neurio_connected":
            case "frequency":
            case "v_l1n":
                if( Device == "site" || Device == null ){
                    ProcessState( "${ it.key }", it.value )
                }
                if( ChildrenEnabled && Device != null ){
                    PostStateToChild( Device, "${ it.key }", it.value )
                }
                break
            // System Status
            case "percentage":
                def Temp = it.value as float
                ProcessState( "${ it.key }", ( Math.round( Temp * 100 ) / 100 ) )
                ProcessEvent( "battery", ( Math.round( Temp * 100 ) / 100 ), "%" )
                if( ChildrenEnabled && Device != null ){
                    PostStateToChild( Device, "${ it.key }", ( Math.round( Temp * 100 ) / 100 ) )
                    PostEventToChild( Device, "battery", ( Math.round( Temp * 100 ) / 100 ), "%" )
                }
                break     
            // Things to make more "friendly"
            case "type":
                if( Device == "site" || Device == null ){
                    ProcessState( "Site Type", it.value )
                }
                if( ChildrenEnabled && Device.contains( "Powerwall" ) ){
                    if( it.value == "acpw" ){
                        PostStateToChild( Device, "Device Type", "AC Powerwall" )
                    } else {
                        PostStateToChild( Device, "Device Type", it.value )
                        Logging( "Powerwall's Device Type was ${ it.value }", 3 )
                    }
                } else if( ChildrenEnabled && Device != null ){
                    PostStateToChild( Device, "Device Type", it.value )
                }
                break
            case "version":
                if( Device == "site" || Device == null ){
                    ProcessState( "Tesla Device Version", it.value )
                }
                if( ChildrenEnabled && Device != null ){
                    PostStateToChild( Device, "Tesla Device Version", it.value )
                }
                break
            case "nominal_system_energy_kWh":
                def Temp = it.value as float
                ProcessEvent( "System Energy (kWh)", ( Math.round( Temp * 100 ) / 100 ), "kWh" )
                if( ChildrenEnabled && Device != null ){
                    PostEventToChild( Device, "System Energy (kWh)", ( Math.round( Temp * 100 ) / 100 ), "kWh" )
                }
                break
            case "nominal_system_power_kW":
                def Temp = it.value as float
                ProcessEvent( "System Power (kW)", ( Math.round( Temp * 100 ) / 100 ), "kW" )
                if( ChildrenEnabled && Device != null ){
                    PostEventToChild( Device, "System Power (kW)", ( Math.round( Temp * 100 ) / 100 ), "kW" )
                }
                break
            case "status":
                if( it.value == "StatusUp" ){
                    ProcessEvent( "System Status", "Up" )
                } else {
                    PostEventToChild( "System Status", "Not Up" )
                    Logging( "System Status identified as Not Up because value was ${ it.value }", 3 )
                }
                if( ChildrenEnabled && Device != null ){
                    if( it.value == "StatusUp" ){
                        ProcessEvent( Device, "System Status", "Up" )
                    } else {
                        PostEventToChild( Device, "System Status", "Not Up" )
                        Logging( "System Status identified as Not Up because value was ${ it.value }", 3 )
                    }
                }
                break
            case "running":
                ProcessEvent( "System Running", "${ it.value }" )
                if( ChildrenEnabled && Device != null ){
                    PostEventToChild( Device, "System Running", "${ it.value }" )
                }
                break
            case "connected_to_tesla":
                if( Device == "site" || Device == null ){
                    ProcessState( "Connected To Tesla", "${ it.value }" )
                }
                if( ChildrenEnabled && Device != null ){
                    PostStateToChild( Device, "Connected To Tesla", "${ it.value }" )
                }
                break
            case "grid_services_active":
                ProcessEvent( "Receiving Power From Grid", "${ it.value }" )
                if( ChildrenEnabled && Device != null ){
                    PostEventToChild( Device, "Receiving Power From Grid", "${ it.value }" )
                }
                break
            case "privacy_notice":
                if( Device == "site" || Device == null ){
                    ProcessState( "Privacy Notice Signed", "${ it.value }" )
                }
                if( ChildrenEnabled && Device != null ){
                    PostStateToChild( Device, "Privacy Notice Signed", "${ it.value }" )
                }
                break
            case "limited_warranty":
                if( Device == "site" || Device == null ){
                    ProcessState( "Under Warranty", "${ it.value }" )
                }
                if( ChildrenEnabled && Device != null ){
                    PostStateToChild( Device, "Under Warranty", "${ it.value }" )
                }
                break
            case "grid_services":
                if( Device == "site" || Device == null ){
                    ProcessState( "Grid Connection Possible", "${ it.value }")
                }
                if( ChildrenEnabled && Device != null ){
                    PostStateToChild( Device, "Grid Connection Possible", "${ it.value }" )
                }
                break
            case "marketing":
                if( Device == "site" || Device == null ){
                    ProcessState( "Receive Marketing", "${ it.value }" )
                }
                if( ChildrenEnabled && Device != null ){
                    PostStateToChild( Device, "Receive Marketing", "${ it.value }" )
                }
                break
            case "registered":
                if( Device == "site" || Device == null ){
                    ProcessState( "System Registered", "${ it.value }" )
                }
                if( ChildrenEnabled && Device != null ){
                    PostStateToChild( Device, "System Registered", "${ it.value }" )
                }
                break
            case "timed_out_registration":
                if( Device == "site" || Device == null ){
                    ProcessState( "Registration Period Over", "${ it.value }" )
                }
                if( ChildrenEnabled && Device != null ){
                    PostStateToChild( Device, "Registration Period Over", "${ it.value }" )
                }
                break
            case "instant_power":
                if( Device != null ){
                    def Temp = it.value as float
                    switch( Device ){
                        case "site":
                            ProcessEvent( "Site Instant Power", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "solar":
                            ProcessEvent( "Solar Instant Power", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "battery":
                            ProcessEvent( "Battery Instant Power", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "load":
                            ProcessEvent( "Load Instant Power", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                    }
                    if( ChildrenEnabled ){
                        PostEventToChild( Device, "Instant Power", ( Math.round( Temp * 100 ) / 100 ) )
                    }
                }
                break
            case "instant_reactive_power":
                if( Device != null ){
                    def Temp = it.value as float
                    switch( Device ){
                        case "site":
                            ProcessEvent( "Site Instant Reactive Power", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "solar":
                            ProcessEvent( "Solar Instant Reactive Power", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "battery":
                            ProcessEvent( "Battery Instant Reactive Power", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "load":
                            ProcessEvent( "Load Instant Reactive Power", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                    }
                    if( ChildrenEnabled ){
                        PostEventToChild( Device, "Instant Reactive Power", ( Math.round( Temp * 100 ) / 100 ) )
                    }
                }
                break
            case "instant_apparent_power":
                if( Device != null ){
                    def Temp = it.value as float
                    switch( Device ){
                        case "site":
                            ProcessEvent( "Site Instant Apparent Power", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "solar":
                            ProcessEvent( "Solar Instant Apparent Power", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "battery":
                            ProcessEvent( "Battery Instant Apparent Power", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "load":
                            ProcessEvent( "Load Instant Apparent Power", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                    }
                    if( ChildrenEnabled ){
                        PostEventToChild( Device, "Instant Apparent Power", ( Math.round( Temp * 100 ) / 100 ) )
                    }
                }
                break
            case "instant_total_current":
                if( Device != null ){
                    def Temp = it.value as float
                    switch( Device ){
                        case "site":
                            ProcessEvent( "Site Total Current", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "solar":
                            ProcessEvent( "Solar Total Current", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "battery":
                            ProcessEvent( "Battery Total Current", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "load":
                            ProcessEvent( "Load Total Current", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                    }
                    if( ChildrenEnabled ){
                        PostEventToChild( Device, "Instant Total Current", ( Math.round( Temp * 100 ) / 100 ) )
                    }
                }
                break
            case "energy_exported":
                if( Device != null ){
                    def Temp = it.value as float
                    switch( Device ){
                        case "site":
                            ProcessEvent( "Site Energy Exported", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "solar":
                            ProcessEvent( "Solar Energy Exported", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "battery":
                            ProcessEvent( "Battery Energy Exported", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "load":
                            ProcessEvent( "Load Energy Exported", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                    }
                    if( ChildrenEnabled ){
                        PostEventToChild( Device, "Energy Exported", ( Math.round( Temp * 100 ) / 100 ) )
                    }
                }
                break
            case "energy_imported":
                if( Device != null ){
                    def Temp = it.value as float
                    switch( Device ){
                        case "site":
                            ProcessEvent( "Site Energy Imported", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "solar":
                            ProcessEvent( "Solar Energy Imported", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "battery":
                            ProcessEvent( "Battery Energy Imported", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                        case "load":
                            ProcessEvent( "Load Energy Imported", ( Math.round( Temp * 100 ) / 100 ) )
                            break
                    }
                    if( ChildrenEnabled ){
                        PostEventToChild( Device, "Energy Imported", ( Math.round( Temp * 100 ) / 100 ) )
                    }
                }
                break
            case "frequency":
                if( Device != null ){
                    def Temp = it.value as float
                    switch( Device ){
                        case "site":
                            ProcessEvent( "Site Frequency (Hz)", ( Math.round( Temp * 100 ) / 100 ), "Hz" )
                            break
                        case "solar":
                            ProcessEvent( "Solar Frequency (Hz)", ( Math.round( Temp * 100 ) / 100 ), "Hz" )
                            break
                        case "battery":
                            ProcessEvent( "Battery Frequency (Hz)", ( Math.round( Temp * 100 ) / 100 ), "Hz" )
                            break
                        case "load":
                            ProcessEvent( "Load Frequency (Hz)", ( Math.round( Temp * 100 ) / 100 ), "Hz" )
                            break
                    }
                    if( ChildrenEnabled ){
                        PostEventToChild( Device, "Frequency (Hz)", ( Math.round( Temp * 100 ) / 100 ), "Hz" )
                    }
                }
                break
            case "instant_average_voltage":
                if( Device != null ){
                    def Temp = it.value as float
                    switch( Device ){
                        case "site":
                            ProcessEvent( "Site Voltage", ( Math.round( Temp * 100 ) / 100 ), "v" )
                            break
                        case "solar":
                            ProcessEvent( "Solar Voltage", ( Math.round( Temp * 100 ) / 100 ), "v" )
                            break
                        case "battery":
                            ProcessEvent( "Battery Voltage", ( Math.round( Temp * 100 ) / 100 ), "v" )
                            break
                        case "load":
                            ProcessEvent( "Load Voltage", ( Math.round( Temp * 100 ) / 100 ), "v" )
                            break
                    }
                    if( ChildrenEnabled ){
                        PostEventToChild( Device, "voltage", ( Math.round( Temp * 100 ) / 100 ), "v" )
                    }
                }
                break
            case "grid_status":
                switch( it.value ){
                    case "SystemGridConnected":
                        ProcessEvent( "Grid Status", "Grid up" )
                        if( ChildrenEnabled && Device != null ){
                            PostEventToChild( Device, "Grid Status", "Grid up" )
                        }
                        break
                    case "SystemIslandedActive":
                        ProcessEvent( "Grid Status", "Grid down" )
                        if( ChildrenEnabled && Device != null ){
                            PostEventToChild( Device, "Grid Status", "Grid down" )
                        }
                        break
                    case "SystemTransitionToGrid":
                        ProcessEvent( "Grid Status", "Grid up still syncing" )
                        if( ChildrenEnabled && Device != null ){
                            PostEventToChild( Device, "Grid Status", "Grid up still syncing" )
                        }
                        break
                }
                break
            // Things to ignore at this time
            case "PackageSerialNumber": // Moved to ignore so it is not recorded anywhere
            case "commissioning_diagnostic":
            case "update_diagnostic":
            case "device_serial":
            case "https_conf":
                Logging( "Ignoring ${ it.key }", 4 )
                break
            // Anything not handled gets to here and gets logged as unhandled so people can sent it to me
            default:
                Logging( "Unhandled data: ${ it.key } = ${ it.value }", 3 )
                break
        }
    }
}

// installed is called when the device is installed, all it really does is run updated
def installed(){
	Logging( "Installed", 2 )
	updated()
}

// initialize is called when the device is initialized, all it really does is run updated
def initialize(){
	Logging( "Initialized", 2 )
	updated()
}

// uninstalling device so make sure to clean up children
void uninstalled() {
	// Delete all children
	getChildDevices().each{
		deleteChildDevice( it.deviceNetworkId )
	}
	Logging( "Uninstalled", 2 )
}

// Process data to check against current state value and then send an event if it has changed
def ProcessEvent( Variable, Value, Unit = null ){
    
    def atMidnight = Variable+' at Midnight';

    
    if( state."${ Variable }" != Value ){
        state."${ Variable }" = Value

        unit = Unit!=null ? Unit : "";

        Logging( "Event: ${ Variable } = ${ Value }${ Unit }", 4 )

        sendEvent( name: "${ Variable }", value: Value, unit: unit, isStateChanged: true );

        if (state."${atMidnight}"!=null){

            val = Value - state."${atMidnight}";
            daily = Variable+' Daily';
            sendEvent( name: "${daily}", value: val, unit: unit, isStateChanged: true );        
        }
    }
}

// Process data to check against current state value and then send an event if it has changed
def ProcessState( Variable, Value ){
    if( state."${ Variable }" != Value ){
        Logging( "State: ${ Variable } = ${ Value }", 4 )
        state."${ Variable }" = Value
    }
}

// Post data to child device
def PostEventToChild( Child, Variable, Value, Unit = null ){
    if( ChildrenEnabled ){
        //def ChildParent = "${ Child } ${ device.deviceNetworkId }"
        def ChildParent = "${ Child }"
        if( ChildParent != null ){
            if( getChildDevice( "${ ChildParent }" ) == null ){
                addSensor( "${ ChildParent }" )
            }
            if( getChildDevice( "${ ChildParent }" ) != null ){
                if( Unit != null ){
                    getChildDevice( "${ ChildParent }" ).ProcessEvent( "${ Variable }", Value, "${ Unit }" )
                    Logging( "Child Event: ${ Variable } = ${ Value }${ Unit }", 4 )
                } else {
                    getChildDevice( "${ ChildParent }" ).ProcessEvent( "${ Variable }", Value )
                    Logging( "Child Event: ${ Variable } = ${ Value }", 4 )
                }
            } else {
                if( Unit != null ){
                    Logging( "Failure to add ${ ChildParent } and post ${ Variable }=${ Value }${ Unit }", 5 )
                } else {
                    Logging( "Failure to add ${ ChildParent } and post ${ Variable }=${ Value }", 5 )
                }
            }
        } else {
            Logging( "Failure to add child because child name was null", 5 )
        }
    }
}

// Post data to child device
def PostStateToChild( Child, Variable, Value ){
    if( ChildrenEnabled ){
        //def ChildParent = "${ Child } ${ device.deviceNetworkId }"
        def ChildParent = "${ Child }"
        if( ChildParent != null ){
            if( getChildDevice( "${ ChildParent }" ) == null ){
                addSensor( "${ ChildParent }" )
            }
            if( getChildDevice( "${ ChildParent }" ) != null ){
                Logging( "Child State: ${ Variable } = ${ Value }", 4 )
                getChildDevice( "${ ChildParent }" ).ProcessState( "${ Variable }", Value )
            } else {
                Logging( "Failure to add ${ ChildParent } and post ${ Variable }=${ Value }", 5 )
            }
        } else {
            Logging( "Failure to add child because child name was null", 5 )
        }
    }
}

// Adds a TeslaChild child device
// Based on @mircolino's method for child sensors
def addSensor( String DNI ){
    try{
        Logging( "addSensor(${ DNI })", 3 )
        addChildDevice( "TeslaChild", DNI, [ name: "${ DNI }" ] )
    }
    catch( Exception e ){
        def Temp = e as String
        if( Temp.contains( "not found" ) ){
            Logging( "TeslaChild driver is not loaded, this is required for child devices.\n Disabling children for rest of refresh.", 5 )
            ChildrenEnabled = false
        } else {
            Logging( "Exception in addSensor: ${ Temp }", 5 )
        }
    }
}

// Handles whether logging is enabled and thus what to put there.
def Logging( LogMessage, LogLevel ){
	// Add all messages as info logging
    if( ( LogLevel == 2 ) && ( LogType != "None" ) ){
        log.info( "${ device.displayName } - ${ LogMessage }" )
    } else if( ( LogLevel == 3 ) && ( ( LogType == "Debug" ) || ( LogType == "Trace" ) ) ){
        log.debug( "${ device.displayName } - ${ LogMessage }" )
    } else if( ( LogLevel == 4 ) && ( LogType == "Trace" ) ){
        log.trace( "${ device.displayName } - ${ LogMessage }" )
    } else if( LogLevel == 5 ){
        log.error( "${ device.displayName } - ${ LogMessage }" )
    }
}

// Checks drdsnell.com for the latest version of the driver
// Original inspiration from @cobra's version checking
def CheckForUpdate(){
    state.Version = "1.0.1"
	state.Driver = "TeslaDriver"
	httpGet( uri: "https://www.drdsnell.com/projects/hubitat/drivers/versions.json", contentType: "application/json" ){ resp ->
        switch( resp.status ){
            case 200:
                if( resp.data."${ state.Driver }" ){
                    CurrentVersion = state.Version.split( /\./ )
                    SiteVersion = resp.data."${ state.Driver }".version.split( /\./ )
                    if( CurrentVersion == SiteVersion ){
                        Logging( "Driver version up to date", 3 )
				        sendEvent( name: "Version", value: "Up to date" )
                    } else if( CurrentVersion[ 0 ] > SiteVersion [ 0 ] ){
                        Logging( "Major development ${ CurrentVersion[ 0 ] }.${ CurrentVersion[ 1 ] }.${ CurrentVersion[ 2 ] } version", 3 )
				        sendEvent( name: "Version", value: "Major development ${ CurrentVersion[ 0 ] }.${ CurrentVersion[ 1 ] }.${ CurrentVersion[ 2 ] } version" )
                    } else if( CurrentVersion[ 1 ] > SiteVersion [ 1 ] ){
                        Logging( "Minor development ${ CurrentVersion[ 0 ] }.${ CurrentVersion[ 1 ] }.${ CurrentVersion[ 2 ] } version", 3 )
				        sendEvent( name: "Version", value: "Minor development ${ CurrentVersion[ 0 ] }.${ CurrentVersion[ 1 ] }.${ CurrentVersion[ 2 ] } version" )
                    } else if( CurrentVersion[ 2 ] > SiteVersion [ 2 ] ){
                        Logging( "Patch development ${ CurrentVersion[ 0 ] }.${ CurrentVersion[ 1 ] }.${ CurrentVersion[ 2 ] } version", 3 )
				        sendEvent( name: "Version", value: "Patch development ${ CurrentVersion[ 0 ] }.${ CurrentVersion[ 1 ] }.${ CurrentVersion[ 2 ] } version" )
                    } else if( SiteVersion[ 0 ] > CurrentVersion[ 0 ] ){
                        Logging( "New major release ${ SiteVersion[ 0 ] }.${ SiteVersion[ 1 ] }.${ SiteVersion[ 2 ] } available", 2 )
				        sendEvent( name: "Version", value: "New major release ${ SiteVersion[ 0 ] }.${ SiteVersion[ 1 ] }.${ SiteVersion[ 2 ] } available" )
                    } else if( SiteVersion[ 1 ] > CurrentVersion[ 1 ] ){
                        Logging( "New minor release ${ SiteVersion[ 0 ] }.${ SiteVersion[ 1 ] }.${ SiteVersion[ 2 ] } available", 2 )
				        sendEvent( name: "Version", value: "New minor release ${ SiteVersion[ 0 ] }.${ SiteVersion[ 1 ] }.${ SiteVersion[ 2 ] } available" )
                    } else if( SiteVersion[ 2 ] > CurrentVersion[ 2 ] ){
                        Logging( "New patch ${ SiteVersion[ 0 ] }.${ SiteVersion[ 1 ] }.${ SiteVersion[ 2 ] } available", 2 )
				        sendEvent( name: "Version", value: "New patch ${ SiteVersion[ 0 ] }.${ SiteVersion[ 1 ] }.${ SiteVersion[ 2 ] } available" )
                    }
                } else {
                    Logging( "Unpublished driver", 3 )
                    sendEvent( name: "Version", value: "Unpublished driver" )
                }
                break
            default:
                Logging( "Unable to check drdsnell.com for driver updates.", 3 )
                break
        }
    }
}
